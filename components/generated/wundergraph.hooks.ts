// Code generated by wunderctl. DO NOT EDIT.

import {
	AddMessageResponse,
	AddMessageInput,
	InternalAddMessageInput,
	InjectedAddMessageInput,
	ChangeUserNameResponse,
	ChangeUserNameInput,
	InternalChangeUserNameInput,
	InjectedChangeUserNameInput,
	DeleteAllMessagesByUserEmailResponse,
	DeleteAllMessagesByUserEmailInput,
	InternalDeleteAllMessagesByUserEmailInput,
	InjectedDeleteAllMessagesByUserEmailInput,
	HelloResponse,
	MessagesResponse,
	MockQueryResponse,
	SetLastLoginResponse,
	SetLastLoginInput,
	InternalSetLastLoginInput,
	InjectedSetLastLoginInput,
	UserInfoResponse,
	InternalUserInfoInput,
	InjectedUserInfoInput,
} from "./models";
import type { WunderGraphRequestContext, Context, WunderGraphRequest, WunderGraphResponse } from "@wundergraph/sdk";
import type { InternalClient } from "./wundergraph.internal.client";
import type { User } from "./wundergraph.server";

export type AuthenticationResponse = AuthenticationOK | AuthenticationDeny;

export interface AuthenticationOK {
	status: "ok";
	user: User;
}

export interface AuthenticationDeny {
	status: "deny";
	message: string;
}

// use SKIP to skip the hook and continue the request / response chain without modifying the request / response
export type SKIP = "skip";

// use CANCEL to skip the hook and cancel the request / response chain
// this is semantically equal to throwing an error (500)
export type CANCEL = "cancel";

export type WUNDERGRAPH_OPERATION =
	| "AddMessage"
	| "ChangeUserName"
	| "DeleteAllMessagesByUserEmail"
	| "Hello"
	| "Messages"
	| "MockQuery"
	| "SetLastLogin"
	| "UserInfo";

export interface GlobalHooksConfig {
	httpTransport?: {
		// onRequest is called right before the request is sent
		// it can be used to modify the request
		// you can return SKIP to skip the hook and continue the request chain without modifying the request
		// you can return CANCEL to cancel the request chain and return a 500 error
		// not returning anything or undefined has the same effect as returning SKIP
		onRequest?: {
			hook: (
				ctx: WunderGraphRequestContext<User>,
				request: WunderGraphRequest
			) => Promise<WunderGraphRequest | SKIP | CANCEL | void>;
			// calling the httpTransport hooks has a case, because the custom httpTransport hooks have to be called for each request
			// for this reason, you have to explicitly enable the hook for each Operation
			enableForOperations?: WUNDERGRAPH_OPERATION[];
			// enableForAllOperations will disregard the enableForOperations property and enable the hook for all operations
			enableForAllOperations?: boolean;
		};
		// onResponse is called right after the response is received
		// it can be used to modify the response
		// you can return SKIP to skip the hook and continue the response chain without modifying the response
		// you can return CANCEL to cancel the response chain and return a 500 error
		// not returning anything or undefined has the same effect as returning SKIP
		onResponse?: {
			hook: (
				ctx: WunderGraphRequestContext<User>,
				response: WunderGraphResponse
			) => Promise<WunderGraphResponse | SKIP | CANCEL | void>;
			// calling the httpTransport hooks has a case, because the custom httpTransport hooks have to be called for each request
			// for this reason, you have to explicitly enable the hook for each Operation
			enableForOperations?: WUNDERGRAPH_OPERATION[];
			// enableForAllOperations will disregard the enableForOperations property and enable the hook for all operations
			enableForAllOperations?: boolean;
		};
	};
}

export type JSONValue = string | number | boolean | JSONObject | Array<JSONValue>;

export type JSONObject = { [key: string]: JSONValue };

export interface HooksConfig {
	global?: GlobalHooksConfig;
	authentication?: {
		postAuthentication?: (user: User) => Promise<void>;
		mutatingPostAuthentication?: (user: User) => Promise<AuthenticationResponse>;
		revalidate?: (user: User) => Promise<AuthenticationResponse>;
	};
	queries?: {
		Hello?: {
			mockResolve?: (ctx: Context<User, InternalClient>) => Promise<HelloResponse>;
			preResolve?: (ctx: Context<User, InternalClient>) => Promise<void>;
			postResolve?: (ctx: Context<User, InternalClient>, response: HelloResponse) => Promise<void>;
			customResolve?: (ctx: Context<User, InternalClient>) => Promise<void | HelloResponse>;
			mutatingPostResolve?: (ctx: Context<User, InternalClient>, response: HelloResponse) => Promise<HelloResponse>;
		};
		Messages?: {
			mockResolve?: (ctx: Context<User, InternalClient>) => Promise<MessagesResponse>;
			preResolve?: (ctx: Context<User, InternalClient>) => Promise<void>;
			postResolve?: (ctx: Context<User, InternalClient>, response: MessagesResponse) => Promise<void>;
			customResolve?: (ctx: Context<User, InternalClient>) => Promise<void | MessagesResponse>;
			mutatingPostResolve?: (
				ctx: Context<User, InternalClient>,
				response: MessagesResponse
			) => Promise<MessagesResponse>;
		};
		MockQuery?: {
			mockResolve?: (ctx: Context<User, InternalClient>) => Promise<MockQueryResponse>;
			preResolve?: (ctx: Context<User, InternalClient>) => Promise<void>;
			postResolve?: (ctx: Context<User, InternalClient>, response: MockQueryResponse) => Promise<void>;
			customResolve?: (ctx: Context<User, InternalClient>) => Promise<void | MockQueryResponse>;
			mutatingPostResolve?: (
				ctx: Context<User, InternalClient>,
				response: MockQueryResponse
			) => Promise<MockQueryResponse>;
		};
		UserInfo?: {
			mockResolve?: (ctx: Context<User, InternalClient>, input: InjectedUserInfoInput) => Promise<UserInfoResponse>;
			preResolve?: (ctx: Context<User, InternalClient>, input: InjectedUserInfoInput) => Promise<void>;
			mutatingPreResolve?: (
				ctx: Context<User, InternalClient>,
				input: InjectedUserInfoInput
			) => Promise<InjectedUserInfoInput>;
			postResolve?: (
				ctx: Context<User, InternalClient>,
				input: InjectedUserInfoInput,
				response: UserInfoResponse
			) => Promise<void>;
			customResolve?: (
				ctx: Context<User, InternalClient>,
				input: InjectedUserInfoInput
			) => Promise<void | UserInfoResponse>;
			mutatingPostResolve?: (
				ctx: Context<User, InternalClient>,
				input: InjectedUserInfoInput,
				response: UserInfoResponse
			) => Promise<UserInfoResponse>;
		};
	};
	mutations?: {
		AddMessage?: {
			mockResolve?: (ctx: Context<User, InternalClient>, input: InjectedAddMessageInput) => Promise<AddMessageResponse>;
			preResolve?: (ctx: Context<User, InternalClient>, input: InjectedAddMessageInput) => Promise<void>;
			mutatingPreResolve?: (
				ctx: Context<User, InternalClient>,
				input: InjectedAddMessageInput
			) => Promise<InjectedAddMessageInput>;
			postResolve?: (
				ctx: Context<User, InternalClient>,
				input: InjectedAddMessageInput,
				response: AddMessageResponse
			) => Promise<void>;
			mutatingPostResolve?: (
				ctx: Context<User, InternalClient>,
				input: InjectedAddMessageInput,
				response: AddMessageResponse
			) => Promise<AddMessageResponse>;
		};
		ChangeUserName?: {
			mockResolve?: (
				ctx: Context<User, InternalClient>,
				input: InjectedChangeUserNameInput
			) => Promise<ChangeUserNameResponse>;
			preResolve?: (ctx: Context<User, InternalClient>, input: InjectedChangeUserNameInput) => Promise<void>;
			mutatingPreResolve?: (
				ctx: Context<User, InternalClient>,
				input: InjectedChangeUserNameInput
			) => Promise<InjectedChangeUserNameInput>;
			postResolve?: (
				ctx: Context<User, InternalClient>,
				input: InjectedChangeUserNameInput,
				response: ChangeUserNameResponse
			) => Promise<void>;
			mutatingPostResolve?: (
				ctx: Context<User, InternalClient>,
				input: InjectedChangeUserNameInput,
				response: ChangeUserNameResponse
			) => Promise<ChangeUserNameResponse>;
		};
		DeleteAllMessagesByUserEmail?: {
			mockResolve?: (
				ctx: Context<User, InternalClient>,
				input: InjectedDeleteAllMessagesByUserEmailInput
			) => Promise<DeleteAllMessagesByUserEmailResponse>;
			preResolve?: (
				ctx: Context<User, InternalClient>,
				input: InjectedDeleteAllMessagesByUserEmailInput
			) => Promise<void>;
			mutatingPreResolve?: (
				ctx: Context<User, InternalClient>,
				input: InjectedDeleteAllMessagesByUserEmailInput
			) => Promise<InjectedDeleteAllMessagesByUserEmailInput>;
			postResolve?: (
				ctx: Context<User, InternalClient>,
				input: InjectedDeleteAllMessagesByUserEmailInput,
				response: DeleteAllMessagesByUserEmailResponse
			) => Promise<void>;
			mutatingPostResolve?: (
				ctx: Context<User, InternalClient>,
				input: InjectedDeleteAllMessagesByUserEmailInput,
				response: DeleteAllMessagesByUserEmailResponse
			) => Promise<DeleteAllMessagesByUserEmailResponse>;
		};
	};
}
